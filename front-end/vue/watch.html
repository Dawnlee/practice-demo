<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vue依赖收集</title>
</head>
<body>

</body>
<script>
    class Dep {
        constructor () {
            this.subs = [];
        }

        addSub (sub) {
            if(this.subs.indexOf(sub) == -1)
            this.subs.push(sub);
        }

        removeSub(sub) {
            remove(this.subs,sub)
        }

        notify () {
            const subs = this.subs.slice()
            for (let i = 0, l = subs.length; i < l; i++) {
                subs[i].update()
            }
        }
    }
    
    function  remove(arr, item) {
        if(arr.length){
            const index = arr.indexOf(item);
            if(index > -1){
                arr.splice(index,1);
            }
        }
    }

    class Watcher {
        constructor (vm, expOrFn, cb, options) {
            this.cb = cb;
            this.vm = vm;

            /*在这里将观察者本身赋值给全局的target，只有被target标记过的才会进行依赖收集*/
            Dep.target = this;
            /*触发渲染操作进行依赖收集*/
            this.cb.call(this.vm);
        }

        update () {
            this.cb.call(this.vm);
        }
    }


    function observe(value,cb) {
        Object.keys(value).forEach(key => defineReactive(value,key,value[key],cb))
    }

    class Vue {
        constructor(options) {
            this._data = options.data;
            _proxy.call(this, options.data);
            observe(this._data, options.render);
            let watcher = new Watcher(this, null, options.render);
        }
    }

    function _proxy(data) {
        const that = this;
        Object.keys(data).forEach(key => {
            Object.defineProperty(that, key, {
                configurable: true,
                enumerable: true,
                get: function proxyGetter() {
                    return that._data[key];
                },
                set: function proxySetter(val) {
                    that._data[key] = val;
                }
            })
        })
    }

    function defineReactive (obj, key, val, cb) {
        /*在闭包内存储一个Dep对象*/
        const dep = new Dep();

        Object.defineProperty(obj, key, {
            enumerable: true,
            configurable: true,
            get: ()=>{
                if (Dep.target) {
                    /*Watcher对象存在全局的Dep.target中*/
                    dep.addSub(Dep.target);
                }
                return val;
            },
            set:newVal=> {
                val = newVal
                /*只有之前addSub中的函数才会触发*/
                dep.notify();
            }
        })
    }

    //将观察者Watcher实例赋值给全局的Dep.target，然后触发render操作只有被Dep.target标记过的才会进行依赖收集。有Dep.target的对象会将Watcher的实例push到subs中，
    // 在对象被修改触发setter操作的时候dep会调用subs中的Watcher实例的update方法进行渲染。

    let app = new Vue({
        el: '#app',
        data: {
            text: 'text',
            text2: 'text2',
            text3: 'text3'
        },
        render(){
            console.log(this._data.text);
            console.log(this._data.text3)
        }
    })
</script>
</html>