今天主要给大家介绍下vue的内部运行机制，主要几点，1点是vue的响应式系统，它是怎么做依赖收集、同步更新视图的。第二点是虚拟dom，我们会讲虚拟dom的好处，它的用处，以及为什么我们要在v-for中使用key值，第三点也是最后要讲的一点vuex状态管理，使用vuex能为我们带来什么好处。



首先我们看一张图，这张图描述了整个vue内部运行流程，希望给大家一个整体的印象，大家基本都使用过vue了，相信对这个流程不会太陌生，然后我们再逐个模块进行讲解。



我们首先会new一个vue，调用init初始化函数，初始化之后会调用$mount挂载组件，然后就是编译过程，如果只有模版，我们就需要编译，这也就是运行时编译。整个编译过程我们就不讲了，它大致为这3个过程，parse用于解析模版中的指令、class等形成ast树，optimize是vue做的一些优化，标记static静态节点，后续diff时会跳过静态节点。generate就是将ast转换成render function。

正文：

接下来正式讲解vue的响应式系统了

我们都知道在mvvm框架里面，更新数据会同步的去更新视图，那么vue是如何实现的呢，vue是通过Object.defineProperty 实现的。

首先我们来看一个最简单的例子。

先定义了一个vue类，然后我们传一些值进行初始化，data就是要传的数据，render就相当于vue中的render function，因为我们这里没有模版以及编译过程，我们暂时就理解为调用render即更新视图。

然后我们看一下初始化过程，在这里我们调用observe来对数据进行观察。也就是当数据进行变化时我们可以调用render函数重新渲染视图。我们会遍历data中属性，为每一个属性set函数添加上render函数。这样当我们对数据进行修改的时候，就会去重新渲染视图。

基本上现在我们的数据就变成了一个响应式的了。

那接下来讲解依赖收集过程了

为什么要进行依赖收集呢，我们看上一个例子，无论我们是赋值this._data.text还是this._data.text2都会去更新视图，这样是一个错误的情况。那么这时候我们就需要依赖收集了，依赖收集让数据知道有多少个地方依赖我。

首先我们定义一个订阅者dep，用来存放观察者，有点类似于发布订阅模式的订阅者，dep里面有个notify，用于通知dep中所有的watcher去执行更新。

然后我们看先new 一个vue实例，和之前的例子一样。我们希望当改变text和text3时进行视图更新，当改变text2不触发更新。在vue构造函数里执行observe，也就是对数据进行观察，和上面讲的一样。不同的是我们在里面创建了一个闭包dep，dep.target用于存放watcher，后面我们调用get的时候会将watcher存入到dep中。

然后我们new一个watcher，这个watcher中会包含render函数，然后在watcher触发渲染函数完成依赖收集。后续当更新text和text3就会触发渲染函数，而这个text2中dep为空的，当为text2赋值时不会去调用渲染函数。

我们知道vue中并不能监听到数组等变化，数组的push splice函数等都是被重新封装过的。那么接下来就稍微讲解下proxy了，proxy在对象前提供了一种拦截方式，相当于代理，当我们需要操纵对象时需要经过这层代理。未来vue3.0也会用到proxy重写响应式这一块。



那接下来就开始讲解virtual dom了

首先先简单介绍下vnode



